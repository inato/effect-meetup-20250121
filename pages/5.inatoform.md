---
layout: center
---

# üì£ Announcing `@inato-form` üéâ

### An open source library to simplify the form experience

<v-click>

### Powered by Effect and Schema ‚Ñ¢Ô∏è

</v-click>

---
layout: center
---

```tsx {*|1-4|5-10|12-17|19-23|*}
import { FormBody, FormDisplay } from "@inato-form/core";
import { TextInput, MultiSelect } from "@inato-form/fields"
import { ReactHookForm } from "@inato-form/react-hook-form"
import { MantineFields } from "@inato-form/mantine"
import { Button } from "@mantine/core"

const FormLive = Layer.provideMerge(
  MantineFields.layer,
  ReactHookForm.layer(Mantine.Button)
);

const definition = FormBody.struct({
  firstName: TextInput.Required,
  lastName: TextInput.Optional,
  email: TextInput.Email.Required,
  favorite: MultiSelect.Default("React", "Angular", "Vue", "Svelte"),
});

export const display = pipe(
  FormDisplay.make(definition),
  Effect.provide(FormLive),
  Effect.runSync
);
```

<style>
.slidev-code-wrapper {
  max-height: unset;
  overflow-y: scroll;
}
</style>


---

# What have we gained?
<br>

<v-click>
Simpler fields with combined <span v-mark.underline.green="2">schema</span> and <span v-mark.underline.orange="2">UI</span> definition in one place: <code><span v-mark.underline.orange="2">TextInput</span>.<span v-mark.underline.green="2">Required</span></code>
</v-click>

<v-clicks at="3">

`Form` component is more about aesthetics, less about mechanics ‚û°Ô∏è lower cognitive load üßëüèº‚Äçüíª

Dependency injection: the choice of external libraries is extracted away ‚ö°Ô∏è

Dry: use `definition.schema` server side to decode API requests

</v-clicks>

<style>
code {
    font-size: 0.9em;
    background: var(--slidev-code-background);
    border-radius: var(--slidev-code-radius);
    padding-top: 0.125rem;
    padding-bottom: 0.125rem;
    padding-left: 0.375rem;
    padding-right: 0.375rem;
    font-weight: 300;
}
</style>

---

# How it works

````md magic-move

```tsx
TextInput ~ [Schema<unknown>, Context<"TextInput",React.FC<Props>>]
```

```tsx
TextInput.Required ~ [Schema<NonEmptyString>, Context<"TextInput",React.FC<Props>>]
```

```tsx
TextInput.Required ~ [Schema<NonEmptyString>, Context<"TextInput",React.FC<Props>>]

FormBody.struct({ firstName: TextInput.Required }) 
  ~ [Schema.Struct<{firstName: Schema<NonEmptyString>}>, { firstName: Context<"TextInput",React.FC<Props>> }]
```

```tsx
TextInput.Required ~ [Schema<NonEmptyString>, Context<"TextInput",React.FC<Props>>]

FormBody.struct({ firstName: TextInput.Required }) 
  ~ [Schema.Struct<{firstName: Schema<NonEmptyString>}>, { firstName: Context<"TextInput",React.FC<Props>> }]

FormDisplay.make = (definition) => 
  Effect.gen(function*() {
    const framework = yield* FormFramework
    const result = {}
    for(const [key, field] of definition) {
      result[key] = yield* field
    }
    return result
  }) // Effect<{ firstName: React.FC<Props> }, never, TextInput | FormFramework>
```

```tsx
TextInput.Required ~ [Schema<NonEmptyString>, Context<"TextInput",React.FC<Props>>]

FormBody.struct({ firstName: TextInput.Required }) 
  ~ [Schema.Struct<{firstName: Schema<NonEmptyString>}>, { firstName: Context<"TextInput",React.FC<Props>> }]

FormDisplay.make = (definition) => 
  Effect.gen(function*() {
    const framework = yield* FormFramework
    const result = {}
    for(const [key, field] of definition) {
      result[key] = yield* field
    }
    return result
  }) // Effect<{ firstName: React.FC<Props> }, never, TextInput | FormFramework>

Effect.provide(display, [Mantine, ReactHookForm]) // Effect<{ firstName: React.FC<Props> }>
```

```tsx
TextInput.Required ~ [Schema<NonEmptyString>, Context<"TextInput",React.FC<Props>>]

FormBody.struct({ firstName: TextInput.Required }) 
  ~ [Schema.Struct<{firstName: Schema<NonEmptyString>}>, { firstName: Context<"TextInput",React.FC<Props>> }]

FormDisplay.make = (definition) => 
  Effect.gen(function*() {
    const framework = yield* FormFramework
    const result = {}
    for(const [key, field] of definition) {
      result[key] = yield* field
    }
    return result
  }) // Effect<{ firstName: React.FC<Props> }, never, TextInput | FormFramework>

Effect.provide(display, [AntD, TanStackForm]) // Effect<{ firstName: React.FC<Props> }>
```

```tsx
TextInput.Required ~ [Schema<NonEmptyString>, Context<"TextInput",React.FC<Props>>]

FormBody.struct({ firstName: TextInput.Required }) 
  ~ [Schema.Struct<{firstName: Schema<NonEmptyString>}>, { firstName: Context<"TextInput",React.FC<Props>> }]

FormDisplay.make = (definition) => 
  Effect.gen(function*() {
    const framework = yield* FormFramework
    const result = {}
    for(const [key, field] of definition) {
      result[key] = yield* field
    }
    return result
  }) // Effect<{ firstName: React.FC<Props> }, never, TextInput | FormFramework>

Effect.provide(display, [Shadcn, MantineForm]) // Effect<{ firstName: React.FC<Props> }>
```
````